# 입찰 동시성 제어 락 전략 성능 분석

## 개요

실시간 경매 시스템에서 동시 입찰 처리 시 발생하는 성능 문제를 분석하고, 다양한 락 전략을 비교 테스트하여 병목 원인을 파악한 문서입니다.

---

## 1. 문제 발생

### 테스트 환경
- VUser: 1000명
- Duration: 2분
- 시나리오: 동일 경매에 대한 동시 입찰

### 초기 상태 (비관적 락)

| 지표 | 결과 |
|------|------|
| TPS | ~100 |
| 평균 응답시간 | 3,605ms |
| p99 응답시간 | 9,826ms |
| 최대 응답시간 | 11,226ms |
| 성공률 | 50% |
| CPU 사용률 | 30% |

### 문제점
- VUser 1000명일 때 TPS는 약 100을 기록
- Latency는 p99 기준 8,600ms, 최대 9,816ms까지 상승
- CPU 사용률은 30% 수준으로 자원 여유가 있었으나 DB Connection Pool이 최대치를 유지
- 커넥션 획득 대기 시간이 35ms 이상 발생
- TPS 급락과 함께 에러 발생

### 영향
- 입찰 버튼을 누르고 결과가 나오기까지 9.8초 이상 소요
- 실시간성이 중요한 경매 프로젝트에서 심각한 문제
- 목표: Latency 500ms 이하로 개선 필요

---

## 2. 1차 시도: DB 커넥션 풀 증가

### 가설
단순히 DB 커넥션 부족으로 인한 커넥션 고갈이 원인일 수 있음

### 조치
DB 커넥션 풀: 10 → 50 증가

### 결과

| 지표 | 변경 전 | 변경 후 |
|------|--------|--------|
| 요청 수 | 23,400 | 30,247 |
| 성공한 입찰 | 11,600 | 15,095 |
| 평균 응답시간 | - | 감소 |
| p95~최대 응답시간 | - | **증가** |

### 분석
- 요청 수와 성공한 입찰 수는 증가
- 평균 응답 시간은 감소
- **그러나 p95~최대 응답 시간은 오히려 증가**
- DB Pool 증가로 처리하지 못한 느린 요청을 처리할 수 있게 되었을 뿐, 근본적인 성능 개선 없음

### 결론
커넥션 풀 증가만으로는 해결 불가. 락 전략 변경 테스트 진행.

---

## 3. 락 전략 비교 테스트

### 테스트 대상
1. 낙관적 락 (Optimistic Lock)
2. 분산락 (Distributed Lock with Redisson)
3. LuaScript (Redis 원자적 연산)

### 전체 결과 요약

| 전략 | 총 요청 | 성공 입찰 | 실패 입찰 | 평균 응답 | p99 | 에러율 | 처리량 |
|------|--------|----------|----------|----------|-----|--------|--------|
| **비관락** | 30,247 | 15,095 | 28 | 3,605ms | 9,826ms | 0.19% | ~252 RPS |
| 낙관락 | 52,329 | 3,164 | 23,000 | 1,744ms | 4,975ms | 87.91% | ❌ |
| 분산락 | 17,309 | 8,632 | 22 | 6,588ms | 11,507ms | 0.25% | ~144 RPS |
| LuaScript | 18,429 | 9,162 | 52 | 6,196ms | 12,158ms | 0.56% | ~154 RPS |

---

### 3.1 낙관적 락 (Optimistic Lock)

#### 구현 방식
- `@Version` 필드 추가
- `@Retryable`로 재시도 로직 (3회)

#### 결과

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 52,329 |
| 성공한 입찰 | 3,164 |
| 실패한 입찰 | 23,000 |
| 평균 응답시간 | 1,744ms |
| p99 응답시간 | 4,975ms |
| 입찰 에러율 | **87.91%** |
| CPU 사용률 | 60% |

#### 분석
- 락 대기 없이 요청을 처리하여 **처리량이 2배 이상 증가**
- 응답시간도 전반적으로 감소
- **하지만 재시도 횟수 3회에서 성공률이 12% (88% 실패)**
- 요청의 대부분이 충돌로 인해 실패
- CPU 사용률 60%로 재시도 횟수 증가는 부하만 증가시킬 뿐 유의미한 개선 불가

#### 결론
**동일 경매 집중 시나리오에 부적합** ❌

---

### 3.2 분산락 (Distributed Lock)

#### 구현 방식
- Redisson `RLock` 사용
- 락이 트랜잭션을 감싸는 구조 (올바른 구현)
- 락 대기 시간: 30초
- Watchdog으로 락 자동 갱신

#### 결과

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 17,309 |
| 성공한 입찰 | 8,632 |
| 실패한 입찰 | 22 |
| 평균 응답시간 | 6,588ms |
| p99 응답시간 | 11,507ms |
| 입찰 에러율 | 0.25% |

#### 분석
- DB 커넥션을 점유하지 않아 커넥션 고갈 방지 기대
- **실제로 커넥션을 점유하지 않는 것을 확인**
- **그러나 오히려 요청 수와 응답시간이 악화**
  - 비관락 대비 처리량 43% 감소 (252 → 144 RPS)
  - 비관락 대비 응답시간 83% 증가 (3,605 → 6,588ms)
- 올바르게 구현(락이 트랜잭션을 감싸는 구조)하면 **완전 직렬화**로 성능 저하
- Redis를 SPOF로 두어야 하고 Redisson 등 복잡도 증가

#### 결론
**비관적 락 대비 이점 없음, 오히려 성능 악화** ❌

---

### 3.3 LuaScript (Redis 원자적 연산)

#### 구현 방식
- Redis Lua 스크립트로 입찰 검증 + 현재가 갱신을 원자적으로 처리
- 락 없이 Redis 단일 스레드 특성으로 동시성 제어
- DB 동기화는 Lua 실행 후 수행

#### 결과

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 18,429 |
| 성공한 입찰 | 9,162 |
| 실패한 입찰 | 52 |
| 평균 응답시간 | 6,196ms |
| p99 응답시간 | 12,158ms |
| 입찰 에러율 | 0.56% |

#### 분석
- Redis 원자적 연산으로 락 없이 동시성 제어
- 비관락 대비 처리량 39% 감소 (252 → 154 RPS)
- 비관락 대비 응답시간 72% 증가 (3,605 → 6,196ms)
- Lua 스크립트 자체는 빠르지만, **이후 동기적 DB 작업이 병목**

#### 결론
**비관락 대비 성능 저하** ❌

---

## 4. RDB 기반 중간 결론

### 테스트 결과 요약

| 항목 | 결과 |
|------|------|
| 최고 성능 전략 | 비관적 락 |
| 비관락 성능 | 평균 3.6초, p99 9.8초 (수용 불가) |
| 타 전략 비교 | 모두 성능 악화 |

### 핵심 발견

**현재 병목은 락 방식이 아닌 RDB I/O에서 발생하는 지연**

- 비관적 락이 모든 지표에서 가장 좋은 성능
- 하지만 평균 3.6초, p99 9.8초의 응답시간은 실시간 경매 서비스에서 수용 불가
- 분산락, LuaScript 등 다른 방식은 오히려 성능이 악화
- 어떤 락 전략을 사용하든 동기적 DB I/O가 존재하는 한 성능 개선 한계

### 다음 단계

RDB에서 트래픽 비중이 높은 조회를 분리하는 CQRS 패턴 도입 검토

---

## 5. CQRS 테스트 (Read: Redis / Write: RDB)

### 5.1 네임드락 + RDB

RDB 기반 추가 테스트로 네임드락도 검증

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 10,159 |
| 성공한 입찰 | 111 |
| 평균 응답시간 | **12,202ms** |
| p99 응답시간 | 19,086ms |
| 입찰 에러율 | **97.81%** |

#### 분석
- 락 유지용 커넥션 + 트랜잭션용 커넥션 별도 필요
- Pool 50개 기준 실질 25개만 사용 가능
- **커넥션 고갈로 에러율 97%**

#### 결론
**커넥션 이중 점유로 부적합** ❌

---

### 5.2 낙관적락 + CQRS

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 51,619 |
| 성공한 입찰 | 1,658 |
| 평균 응답시간 | 1,631ms |
| p99 응답시간 | **16,200ms** |
| 입찰 에러율 | **93.58%** |

#### 분석
- Redis 조회 속도 향상으로 **동시성 충돌 급증**
- RDB 조회가 자연스러운 트래픽 조절 역할을 했었음
- 조회 병목 제거 → Write 요청 집중 → 충돌률 급증

#### 결론
**Read 최적화가 오히려 Write 병목 심화** ❌

---

### 5.3 분산락 + CQRS

락 설정별 비교 테스트:

| 설정 | 처리량 | 평균 응답시간 | 에러율 |
|------|--------|--------------|--------|
| 락대기 3초 / 유지 5초 | 22,095 | 5,058ms | 16.54% |
| 락대기 10초 / 유지 3초 | 16,595 | 7,008ms | 3.07% |
| 락대기 5초 / 유지 2초 | 23,917 | 4,653ms | 12.03% |

#### 분석
- 락 대기시간 ↑ → 에러율 ↓, 응답시간 ↑
- 비관적락+RDB 대비 성공 횟수 21% 개선, 응답시간 30% 개선
- 그러나 **에러율 48배 증가** (0.25% → 12%)
- Redis의 빠른 조회로 Write 요청이 RDB에 집중 → 락 대기 타임아웃 급증

#### 결론
**네트워크 왕복 비용 추가로 비관락+RDB 대비 성능 저하** ❌

---

### 5.4 CQRS 결론

| 방식 | vs 비관락+RDB |
|------|--------------|
| 낙관적락 + CQRS | 에러율 93% (충돌 급증) |
| 분산락 + CQRS | 에러율 12% (타임아웃 급증) |

**핵심 발견:**
- Read 최적화만으로는 Write 병목 해결 불가
- 락 안에서 Read 시간 단축해도 전체 성능 미개선 → **Write가 대부분 차지**
- 네트워크 왕복 비용 추가로 오히려 성능 저하

**⇒ Write도 Redis에서 처리하는 방식으로 전환**

---

## 6. Redis Main DB 테스트 (1000 VUs)

### 6.1 낙관적락 + Redis

| 지표 | 결과 |
|------|------|
| 총 요청 수 | **226,793** |
| 성공한 입찰 | 113,271 |
| 평균 응답시간 | **10.48ms** |
| p95 응답시간 | 25.95ms |
| p99 응답시간 | 190.15ms |
| 입찰 에러율 | **0.11%** |

#### 분석
- RDB 비관적락 대비 **344배 빠른 응답시간** (3,605ms → 10.48ms)
- 처리량 **7.5배 증가** (30,247 → 226,793)
- RDB 낙관적락 에러율 87% → **0.11%로 급감**
- Redis 빠른 Write가 충돌 윈도우 최소화

---

### 6.2 분산락 + Redis

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 123,231 |
| 성공한 입찰 | 61,532 |
| 평균 응답시간 | **435ms** |
| p99 응답시간 | 1,310ms |
| 입찰 에러율 | 0.13% |

#### 분석
- 목표 500ms 충족
- 그러나 낙관적락 대비 **42배 느림**
- 락 획득/해제 + R/W 과정에서 네트워크 왕복 4회 발생
- 처리량도 낙관적락의 54% 수준

---

### 6.3 Lua Script + Redis

| 지표 | 결과 |
|------|------|
| 총 요청 수 | **225,905** |
| 성공한 입찰 | 112,830 |
| 평균 응답시간 | **4.53ms** |
| p95 응답시간 | 5.01ms |
| p99 응답시간 | **17.47ms** |
| 입찰 에러율 | **0.11%** |

#### 분석
- RDB 비관적락 대비 **796배 빠른 응답시간** (3,605ms → 4.53ms)
- 처리량 **7.5배 증가**
- 낙관적락 대비 **2.3배 빠름** (10.48ms → 4.53ms)
- **p99 17ms로 꼬리 지연 11배 개선** (낙관적락 190ms)
- Read-Modify-Write 원자적 실행으로 네트워크 왕복 1회

---

### 6.4 10000 VUs 추가 검증

| 방식 | 평균 응답시간 | p99 | 처리량 | 에러율 |
|------|-------------|-----|--------|--------|
| 낙관적락 + Redis | 1,182ms | 1,915ms | 435,964 | 0.52% |
| Lua Script + Redis | **675ms** | 2,855ms | **469,379** | **0.14%** |

---

## 7. 최종 결론

### 전체 테스트 결과 비교 (1000 VUs)

| 방식 | 평균 응답시간 | p99 | 처리량 | 에러율 |
|------|-------------|-----|--------|--------|
| 비관적락 + RDB | 3,605ms | 9,826ms | 30,247 | 2.50% |
| 낙관적락 + RDB | 1,744ms | 4,975ms | 52,329 | 87.91% |
| 분산락 + RDB | 6,588ms | 11,507ms | 17,309 | 0.25% |
| 네임드락 + RDB | 12,202ms | 19,086ms | 10,159 | 97.81% |
| 낙관적락 + CQRS | 1,631ms | 16,200ms | 51,619 | 93.58% |
| 분산락 + CQRS | 4,653ms | 11,215ms | 23,917 | 12.03% |
| 낙관적락 + Redis | 10.48ms | 190ms | 226,793 | 0.11% |
| 분산락 + Redis | 435ms | 1,310ms | 123,231 | 0.13% |
| **Lua Script + Redis** | **4.53ms** | **17ms** | **225,905** | **0.11%** |

### 성능 개선 요약

```
RDB 비관적락 (3,605ms)
    ↓ Redis Main DB 전환
낙관적락 + Redis (10.48ms) : 344배 개선
    ↓ Lua Script 적용
Lua Script + Redis (4.53ms) : 796배 개선
```

| 개선 항목 | Before | After | 개선율 |
|----------|--------|-------|--------|
| 평균 응답시간 | 3,605ms | 4.53ms | **796배** |
| 꼬리 지연 (p99) | 9,826ms | 17ms | **578배** |
| 처리량 | 30,247건 | 225,905건 | **7.5배** |
| 에러율 | 2.50% | 0.11% | **95.6% 감소** |

### 핵심 발견

1. **RDB 기반 락 전략은 한계가 명확함**
   - 비관적락이 RDB에서 최선이나 실시간 경매에 부적합
   - 낙관적락, 분산락, 네임드락 모두 성능/안정성 면에서 열위

2. **CQRS(Read: Redis)만으로는 부족함**
   - Read 최적화가 오히려 Write 병목 심화
   - 네트워크 왕복 비용 추가로 성능 저하

3. **Redis Main DB + Lua Script가 최적 해법**
   - Read-Modify-Write 원자적 실행
   - 네트워크 왕복 1회로 극한의 지연 최소화
   - 충돌 개념 없이 일관된 응답 품질 보장

### 최종 선택

| 항목 | 결정 |
|------|------|
| 동시성 제어 | Lua Script + Redis |
| 데이터 저장소 | Redis (Primary) + RDB (비동기 동기화) |
| 목표 달성 | 500ms → **4.53ms** (109배 초과 달성) |

---

## 8. 예상 vs 현실: 테스트 중 발견한 의외의 결과

### 8.1 분산락이 비관적락보다 느렸다

| 항목 | 예상 | 실제 |
|------|------|------|
| 분산락 성능 | DB 커넥션 미점유로 비관락보다 빠를 것 | **비관락 대비 83% 느림** (3.6초 → 6.6초) |

**왜 예상과 달랐나:**
- "올바른 구현"(락이 트랜잭션을 감싸는 구조)이 완전 직렬화를 유발
- Redis 락 획득 → 트랜잭션 시작 → 커밋 → 락 해제의 순차 처리
- DB 락은 병렬 읽기라도 허용하지만, 분산락은 모든 것을 직렬화

**배운 점:** 분산락은 "락 밖에서 빠른 작업"이 있을 때 유리. RDB I/O 자체가 병목이면 의미 없음.

---

### 8.2 CQRS(Read: Redis)가 오히려 성능을 악화시켰다

| 항목 | 예상 | 실제 |
|------|------|------|
| 낙관적락 + CQRS | Read 최적화로 전체 성능 향상 | **에러율 87% → 93%로 악화** |
| 분산락 + CQRS | 빠른 조회로 응답시간 개선 | **에러율 0.25% → 12%로 48배 증가** |

**왜 예상과 달랐나:**
- RDB 조회가 "자연스러운 트래픽 조절" 역할을 하고 있었음
- 조회가 빨라지니 Write 요청이 DB에 집중 → 충돌/타임아웃 급증
- Read 병목 제거 → Write 병목 심화라는 예상 못한 연쇄 효과

**배운 점:** 병목은 옮겨다닌다. Read만 최적화하면 Write가 터진다.

---

### 8.3 Lua Script가 RDB에서는 효과가 없었다

| 항목 | 예상 | 실제 |
|------|------|------|
| Lua Script + 동기 RDB | Redis 원자 연산으로 락 불필요, 성능 향상 | **비관락 대비 72% 느림** |
| Lua Script + Redis Main | - | **796배 빠름** |

**왜 예상과 달랐나:**
- Lua 스크립트 자체는 마이크로초 단위로 빠름
- 하지만 **이후 동기적 RDB 저장이 병목**
- Redis에서 빠르게 처리해도 RDB 대기열에 쌓이면 의미 없음

**배운 점:** 원자 연산의 이점은 "저장소가 빠를 때"만 발휘됨. 결국 RDB I/O가 근본 원인.

---

### 8.4 요약: 테스트 전 가설이 틀렸던 것들

| 가설 | 결과 | 교훈 |
|------|------|------|
| "커넥션 풀 늘리면 해결" | p95~max 응답시간 **오히려 증가** | 근본 원인 해결 없이 자원만 늘리면 느린 요청만 더 처리 |
| "분산락이 더 빠를 것" | 비관락보다 **83% 느림** | 올바른 구현 = 완전 직렬화 |
| "Read 최적화가 도움될 것" | Write 병목 **심화** | 병목은 이동한다 |
| "Lua Script면 락 불필요" | RDB에서는 **효과 없음** | 저장소 속도가 핵심 |

---

## 참고

- 관련 이슈: [#28 입찰 동시성 제어 락 전략 성능 테스트](https://github.com/ahn-h-j/Fairbid/issues/28)
- 테스트 도구: k6
- 모니터링: Prometheus + Grafana
