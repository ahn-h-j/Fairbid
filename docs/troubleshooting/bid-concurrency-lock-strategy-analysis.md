# 입찰 동시성 제어 락 전략 성능 분석

## 개요

실시간 경매 시스템에서 동시 입찰 처리 시 발생하는 성능 문제를 분석하고, 다양한 락 전략을 비교 테스트하여 병목 원인을 파악한 문서입니다.

---

## 1. 문제 발생

### 테스트 환경
- VUser: 1000명
- Duration: 2분
- 시나리오: 동일 경매에 대한 동시 입찰

### 초기 상태 (비관적 락)

| 지표 | 결과 |
|------|------|
| TPS | ~100 |
| 평균 응답시간 | 3,605ms |
| p99 응답시간 | 9,826ms |
| 최대 응답시간 | 11,226ms |
| 성공률 | 50% |
| CPU 사용률 | 30% |

### 문제점
- VUser 1000명일 때 TPS는 약 100을 기록
- Latency는 p99 기준 8,600ms, 최대 9,816ms까지 상승
- CPU 사용률은 30% 수준으로 자원 여유가 있었으나 DB Connection Pool이 최대치를 유지
- 커넥션 획득 대기 시간이 35ms 이상 발생
- TPS 급락과 함께 에러 발생

### 영향
- 입찰 버튼을 누르고 결과가 나오기까지 9.8초 이상 소요
- 실시간성이 중요한 경매 프로젝트에서 심각한 문제
- 목표: Latency 500ms 이하로 개선 필요

---

## 2. 1차 시도: DB 커넥션 풀 증가

### 가설
단순히 DB 커넥션 부족으로 인한 커넥션 고갈이 원인일 수 있음

### 조치
DB 커넥션 풀: 10 → 50 증가

### 결과

| 지표 | 변경 전 | 변경 후 |
|------|--------|--------|
| 요청 수 | 23,400 | 30,247 |
| 성공한 입찰 | 11,600 | 15,095 |
| 평균 응답시간 | - | 감소 |
| p95~최대 응답시간 | - | **증가** |

### 분석
- 요청 수와 성공한 입찰 수는 증가
- 평균 응답 시간은 감소
- **그러나 p95~최대 응답 시간은 오히려 증가**
- DB Pool 증가로 처리하지 못한 느린 요청을 처리할 수 있게 되었을 뿐, 근본적인 성능 개선 없음

### 결론
커넥션 풀 증가만으로는 해결 불가. 락 전략 변경 테스트 진행.

---

## 3. 락 전략 비교 테스트

### 테스트 대상
1. 낙관적 락 (Optimistic Lock)
2. 분산락 (Distributed Lock with Redisson)
3. LuaScript (Redis 원자적 연산)

### 전체 결과 요약

| 전략 | 총 요청 | 성공 입찰 | 실패 입찰 | 평균 응답 | p99 | 에러율 | 처리량 |
|------|--------|----------|----------|----------|-----|--------|--------|
| **비관락** | 30,247 | 15,095 | 28 | 3,605ms | 9,826ms | 0.19% | ~252 RPS |
| 낙관락 | 52,329 | 3,164 | 23,000 | 1,744ms | 4,975ms | 87.91% | ❌ |
| 분산락 | 17,309 | 8,632 | 22 | 6,588ms | 11,507ms | 0.25% | ~144 RPS |
| LuaScript | 18,429 | 9,162 | 52 | 6,196ms | 12,158ms | 0.56% | ~154 RPS |

---

### 3.1 낙관적 락 (Optimistic Lock)

#### 구현 방식
- `@Version` 필드 추가
- `@Retryable`로 재시도 로직 (3회)

#### 결과

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 52,329 |
| 성공한 입찰 | 3,164 |
| 실패한 입찰 | 23,000 |
| 평균 응답시간 | 1,744ms |
| p99 응답시간 | 4,975ms |
| 입찰 에러율 | **87.91%** |
| CPU 사용률 | 60% |

#### 분석
- 락 대기 없이 요청을 처리하여 **처리량이 2배 이상 증가**
- 응답시간도 전반적으로 감소
- **하지만 재시도 횟수 3회에서 성공률이 12% (88% 실패)**
- 요청의 대부분이 충돌로 인해 실패
- CPU 사용률 60%로 재시도 횟수 증가는 부하만 증가시킬 뿐 유의미한 개선 불가

#### 결론
**동일 경매 집중 시나리오에 부적합** ❌

---

### 3.2 분산락 (Distributed Lock)

#### 구현 방식
- Redisson `RLock` 사용
- 락이 트랜잭션을 감싸는 구조 (올바른 구현)
- 락 대기 시간: 30초
- Watchdog으로 락 자동 갱신

#### 결과

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 17,309 |
| 성공한 입찰 | 8,632 |
| 실패한 입찰 | 22 |
| 평균 응답시간 | 6,588ms |
| p99 응답시간 | 11,507ms |
| 입찰 에러율 | 0.25% |

#### 분석
- DB 커넥션을 점유하지 않아 커넥션 고갈 방지 기대
- **실제로 커넥션을 점유하지 않는 것을 확인**
- **그러나 오히려 요청 수와 응답시간이 악화**
  - 비관락 대비 처리량 43% 감소 (252 → 144 RPS)
  - 비관락 대비 응답시간 83% 증가 (3,605 → 6,588ms)
- 올바르게 구현(락이 트랜잭션을 감싸는 구조)하면 **완전 직렬화**로 성능 저하
- Redis를 SPOF로 두어야 하고 Redisson 등 복잡도 증가

#### 결론
**비관적 락 대비 이점 없음, 오히려 성능 악화** ❌

---

### 3.3 LuaScript (Redis 원자적 연산)

#### 구현 방식
- Redis Lua 스크립트로 입찰 검증 + 현재가 갱신을 원자적으로 처리
- 락 없이 Redis 단일 스레드 특성으로 동시성 제어
- DB 동기화는 Lua 실행 후 수행

#### 결과

| 지표 | 결과 |
|------|------|
| 총 요청 수 | 18,429 |
| 성공한 입찰 | 9,162 |
| 실패한 입찰 | 52 |
| 평균 응답시간 | 6,196ms |
| p99 응답시간 | 12,158ms |
| 입찰 에러율 | 0.56% |

#### 분석
- Redis 원자적 연산으로 락 없이 동시성 제어
- 비관락 대비 처리량 39% 감소 (252 → 154 RPS)
- 비관락 대비 응답시간 72% 증가 (3,605 → 6,196ms)
- Lua 스크립트 자체는 빠르지만, **이후 동기적 DB 작업이 병목**

#### 결론
**비관락 대비 성능 저하** ❌

---

## 4. 결론

### 테스트 결과 요약

| 항목 | 결과 |
|------|------|
| 최고 성능 전략 | 비관적 락 |
| 비관락 성능 | 평균 3.6초, p99 9.8초 (수용 불가) |
| 타 전략 비교 | 모두 성능 악화 |

### 핵심 발견

**현재 병목은 락 방식이 아닌 동기적 RDB I/O에서 발생하는 지연**

- 비관적 락이 모든 지표에서 가장 좋은 성능
- 하지만 평균 3.6초, p99 9.8초의 응답시간은 실시간 경매 서비스에서 수용 불가
- 분산락, LuaScript 등 다른 방식은 오히려 성능이 악화
- 어떤 락 전략을 사용하든 동기적 DB I/O가 존재하는 한 성능 개선 한계

### 최종 결정

| 항목 | 결정 |
|------|------|
| 락 전략 변경 | **불필요** (락이 병목이 아님) |
| 병목 원인 | 동기적 RDB I/O |
| 다음 단계 | DB 쓰기 비동기화로 아키텍처 개선 필요 |

---

## 5. 다음 단계

### 개선 방향: Write-Behind 패턴 도입

```
현재 (Write-Through):
[요청] → [락/Lua] → [DB 동기화] → [응답]
                         ↑
                      병목 지점

개선 (Write-Behind):
[요청] → [Redis 처리] → [응답]
              ↓ (비동기)
         [DB 동기화]
```

### 단계별 개선 계획

1. **불필요한 쿼리 제거**
   - 이벤트 발행용 경매 재조회 제거

2. **@Async로 DB 쓰기 비동기화 테스트**
   - 간단한 구현으로 효과 검증

3. **Redis Stream + Consumer로 Write-Behind 구현**
   - 안정적인 비동기 처리
   - 실패 시 재처리 가능

### 기대 효과
- 응답 시간: 3,600ms → 수십 ms
- 처리량: 252 RPS → 수천 RPS

---

## 참고

- 관련 이슈: [#28 입찰 동시성 제어 락 전략 성능 테스트](https://github.com/ahn-h-j/Fairbid/issues/28)
- 테스트 도구: k6
- 모니터링: Prometheus + Grafana
