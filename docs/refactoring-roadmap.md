# FairBid 아키텍처 진화 로드맵

> 이 문서는 모놀리식 RDB 기반 아키텍처에서 Redis 중심 분산 아키텍처로의 단계적 전환 과정을 기록한다.
> 각 단계의 의사결정 과정과 트레이드오프를 문서화하여 포트폴리오로 활용한다.

---

## 1. 프로젝트 개요

### 1.1 현재 상태
| 항목 | 현재 |
|------|------|
| 아키텍처 | 모놀리식 (헥사고날 + DDD) |
| 메인 DB | MySQL (RDB) |
| 실시간 통신 | WebSocket + STOMP (Spring Simple Broker) |
| 캐시 | 미적용 |
| 동시성 제어 | 비관적 락 (JPA `findByIdWithLock`) |
| 스케줄러 | `@Scheduled` (단일 서버 가정) |
| 모니터링 | Actuator만 |
| 인프라 | 단일 EC2 |

### 1.2 최종 목표
| 항목 | 목표 |
|------|------|
| 메인 DB | Redis (진행 중인 경매만) |
| 영속성 | MQ를 통한 비동기 RDB 저장 |
| 서버 구조 | Stateless HTTP + Stateful WebSocket 분리 |
| 서버간 통신 | Pub/Sub 기반 |
| 동시성 제어 | Redis 기반 (Redisson or Lua) |
| 인프라 | ECS (수평확장 가능) |

### 1.3 핵심 원칙
```
1. 과도한 설계 금지 - 실제 문제가 없으면 미리 복잡하게 만들지 않는다
2. 측정 없는 최적화 금지 - 감으로 개선하지 않고 데이터로 판단한다
3. 문서화 필수 - 왜 이렇게 했는지 기록 없이 끝내지 않는다
4. 프로젝트 적합성 - "이 문제를 해결하는데 적합한가"가 기준이다
```

---

## 2. 단계별 로드맵

### Phase 0: 측정 환경 구축 (현재 단계)
> **목표**: 현재 성능 베이스라인 측정, 병목 지점 파악

```
[현재]                          [Phase 0 완료]
Actuator만          →          Prometheus + Grafana + k6
성능 모름                       베이스라인 확보, 병목 파악
```

**산출물**:
- [ ] 모니터링 대시보드 (Grafana)
- [ ] k6 부하테스트 스크립트 (복합 시나리오)
- [ ] 베이스라인 성능 리포트
- [ ] 병목 지점 분석 문서

**테스트 시나리오** (복합):
1. 동시 입찰 경합 - 여러 사용자가 하나의 경매에 동시 입찰
2. WebSocket 동시 연결 - 많은 클라이언트가 실시간 구독
3. 경매 목록 조회 - 단순 읽기 부하

---

### Phase 1: Redis 캐시 도입
> **목표**: DB 읽기 부하 감소, Redis 운영 경험 축적

**조건**: Phase 0에서 DB 읽기가 병목으로 확인될 경우

```
[Phase 0]                       [Phase 1 완료]
모든 조회 DB 직접    →          조회 캐시 (Redis)
                               진행 중 경매 데이터 Redis 저장
```

**트레이드오프 분석 필요**:
| 항목 | 선택지 | 고려사항 |
|------|--------|----------|
| 캐시 범위 | 경매 목록만 vs 경매 상세까지 | 캐시 무효화 복잡도 |
| 캐시 전략 | Cache-Aside vs Write-Through | 일관성 vs 성능 |
| TTL 설정 | 짧게 vs 길게 | 실시간성 vs 캐시 히트율 |

**산출물**:
- [ ] Redis 캐시 적용 코드
- [ ] 캐시 히트율 측정
- [ ] Before/After 성능 비교 리포트

---

### Phase 2: Redis를 입찰 데이터 Primary Storage로
> **목표**: 입찰 처리 성능 극대화

**조건**: Phase 0/1에서 DB 쓰기(입찰)가 병목으로 확인될 경우

```
[Phase 1]                       [Phase 2 완료]
입찰 → MySQL 직접 저장  →       입찰 → Redis 저장 → 비동기 MySQL
비관적 락                        Redis 기반 동시성 제어
```

**트레이드오프 분석 필요**:

#### 2-1. 동시성 제어 전략
| 선택지 | 장점 | 단점 | 적합한 경우 |
|--------|------|------|-------------|
| Redisson 분산락 | 기존 비관적 락과 유사한 패턴, 학습 곡선 낮음 | 락 대기 시간, 네트워크 왕복 | 기존 코드 구조 유지 원할 때 |
| Lua 스크립트 원자성 | 락 없이 원자적 처리, 성능 좋음 | 복잡한 로직 구현 어려움 | 단순한 검증+갱신 로직 |
| 낙관적 동시성 (버전) | 충돌 적을 때 성능 좋음 | 충돌 시 재시도 필요 | 동시 입찰이 드문 경우 |

#### 2-2. 데이터 유실 허용 범위 (핵심 트레이드오프)
```
문제: 입찰 데이터를 Redis에 먼저 쓰고 MQ로 RDB에 비동기 저장 시,
      Redis 장애나 MQ 유실 시 데이터 손실 가능

시나리오:
- 마지막 입찰이 유실되면 → 낙찰자가 달라짐 (치명적)
- 중간 입찰 이력 유실 → 기록만 누락 (덜 치명적)
```

| 선택지 | 성능 | 일관성 | 복잡도 |
|--------|------|--------|--------|
| Redis만 신뢰 | 최고 | 유실 가능 | 낮음 |
| Redis + 동기 RDB | 낮음 | 보장 | 낮음 |
| Redis + MQ + 확인 | 높음 | 거의 보장 | 높음 |
| 이벤트 소싱 | 중간 | 재구성 가능 | 매우 높음 |

**산출물**:
- [ ] 동시성 전략 결정 및 근거 문서
- [ ] 데이터 일관성 전략 결정 및 근거 문서
- [ ] 구현 코드
- [ ] Before/After 성능 비교 리포트

---

### Phase 3: WebSocket 서버 분리
> **목표**: HTTP 서버 Stateless화, 독립적 스케일링

**조건**: Phase 0에서 WebSocket 연결이 병목이거나, 수평확장이 필요할 때

```
[Phase 2]                       [Phase 3 완료]
단일 서버                →       HTTP 서버 + WebSocket 서버
(모놀리식)                       Pub/Sub으로 통신
```

**트레이드오프 분석 필요**:

#### 3-1. 서버간 통신 방식
| 선택지 | 장점 | 단점 | 적합한 경우 |
|--------|------|------|-------------|
| Redis Pub/Sub | 추가 인프라 없음, 간단 | 메시지 유실 가능, 히스토리 없음 | 실시간 브로드캐스트 |
| Redis Stream | 메시지 지속성, 컨슈머 그룹 | Pub/Sub보다 복잡 | 메시지 유실 방지 필요 시 |
| Kafka | 대용량, 높은 신뢰성, 리플레이 | 운영 복잡, 학습 곡선 | 대규모 이벤트 스트리밍 |
| RabbitMQ | 안정적, 다양한 패턴 | 추가 인프라 | 복잡한 라우팅 필요 시 |

#### 3-2. WebSocket 세션 저장소
| 선택지 | 장점 | 단점 |
|--------|------|------|
| 로컬 메모리 | 간단, 빠름 | Sticky Session 필요, 장애 시 세션 유실 |
| Redis | 세션 공유, WS 서버도 Stateless | 네트워크 오버헤드, 복잡도 증가 |

**산출물**:
- [ ] 서버간 통신 방식 결정 및 근거 문서
- [ ] 분리된 서버 코드
- [ ] Before/After 성능 비교 리포트

---

### Phase 4: 수평 확장 및 운영 안정화
> **목표**: 다중 인스턴스 운영, 장애 대응

**조건**: Phase 3 완료 후, 실제 스케일아웃이 필요할 때

```
[Phase 3]                       [Phase 4 완료]
서버 분리됨            →         다중 인스턴스
스케줄러 중복 가능               분산 스케줄러
```

**발생 시 해결할 문제들**:
- 스케줄러 중복 실행 → ShedLock 또는 리더 선출
- 장애 복구 → 헬스체크, 자동 재시작
- 로드밸런싱 → ALB/NLB 설정

---

## 3. 지금 당장 해야 할 것 (Phase 0)

### 3.1 모니터링 환경 구축
```
1. Prometheus 설정
   - Actuator /actuator/prometheus 엔드포인트 활성화
   - Prometheus 서버 Docker Compose 추가

2. Grafana 대시보드
   - JVM 메트릭 (힙, GC, 스레드)
   - HTTP 요청 메트릭 (처리량, 응답시간, 에러율)
   - DB 커넥션 풀 메트릭
   - WebSocket 연결 수

3. 커스텀 메트릭 추가
   - 입찰 처리 시간
   - 경매당 동시 입찰 수
   - WebSocket 메시지 브로드캐스트 시간
```

### 3.2 k6 부하테스트 스크립트 작성
```
시나리오 1: 동시 입찰 경합
- 1개 경매에 N명이 동시 입찰
- 측정: 성공률, 응답시간, DB 락 대기시간

시나리오 2: WebSocket 동시 연결
- M개 경매에 각각 K명 구독
- 측정: 연결 성공률, 메시지 지연시간

시나리오 3: 복합 시나리오
- 경매 목록 조회 + 입찰 + WebSocket 구독 동시
- 측정: 전체 시스템 처리량, 리소스 사용률
```

### 3.3 베이스라인 측정 및 병목 분석
```
측정 항목:
- 단일 서버 최대 TPS
- p50, p95, p99 응답시간
- 병목 지점 (CPU? DB? 네트워크? 락?)

분석 후 결정:
- 어떤 Phase를 먼저 진행할지
- 어떤 트레이드오프를 우선 분석할지
```

---

## 4. 의사결정 기록

> 각 단계별로 의사결정이 이루어지면 여기에 기록한다.

### Phase 0 의사결정
| 날짜 | 결정 사항 | 선택지 | 선택 | 근거 |
|------|-----------|--------|------|------|
| - | - | - | - | - |

### Phase 1 의사결정
| 날짜 | 결정 사항 | 선택지 | 선택 | 근거 |
|------|-----------|--------|------|------|
| - | - | - | - | - |

*(Phase 2, 3, 4도 동일한 형식으로 기록)*

---

## 5. 성능 측정 기록

> Before/After 성능 데이터를 기록한다.

### 베이스라인 (Phase 0 측정)
| 시나리오 | TPS | p50 | p95 | p99 | 비고 |
|----------|-----|-----|-----|-----|------|
| - | - | - | - | - | - |

### Phase 1 완료 후
| 시나리오 | TPS | p50 | p95 | p99 | 개선율 |
|----------|-----|-----|-----|-----|--------|
| - | - | - | - | - | - |

*(Phase 2, 3, 4도 동일한 형식으로 기록)*

---

## 6. 유지해야 할 것들

### 6.1 아키텍처
- **헥사고날 구조 유지**: Port 인터페이스만 구현체 교체 (JPA → Redis)
- **DDD 바운디드 컨텍스트**: 도메인 경계 유지

### 6.2 테스트
- **기존 Cucumber 테스트**: 회귀 테스트로 활용
- **리팩터링 후 기존 기능 정상 동작 확인 필수**

### 6.3 코드 품질
- 기존 코딩 컨벤션 (`/docs/convention.md`) 준수

---

## 7. 학습 목표

이 프로젝트를 통해 얻고자 하는 것:
- [ ] Redis 실무 적용 경험 (캐시, Pub/Sub, 데이터 저장소)
- [ ] 성능 프로파일링 능력 (병목 찾고 개선하는 사이클)
- [ ] 분산 시스템 설계 경험 (서버 분리, 메시징, 동시성)
- [ ] 문제 정의 → 해결까지 전체 과정 경험

---

*마지막 업데이트: 2026-01-15*
